# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2022, IPI PAN
# This file is distributed under the same license as the Korpusomat EU
# package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Korpusomat EU 0.1.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-03-09 16:58+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: en\n"
"Language-Team: en <LL@li.org>\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.11.0\n"

#: ../../mtas.rst:3 e5ce1970e90b4709aa8819faa9f26941
msgid "Tworzenie zapytań do korpusu"
msgstr "Corpus Query Language"

#: ../../mtas.rst:5 990117e854ac44208346131b467b0cda
msgid ""
"Niniejsza część instrukcji opisuje język zapytań CQL w odniesieniu do "
"warstw znakowania dostępnych w Korpusomacie."
msgstr ""
"This section comprises a guide into the Corpus Query Language, which "
"takesinto account the different layers of annotation available in "
"Korpusomat."

#: ../../mtas.rst:8 38cd9ac163d044caa05abdedf7737530
msgid "Segmentacja"
msgstr "Tokenisation"

#: ../../mtas.rst:10 f89dd294bc03481eab407e0ebe31e2f0
msgid ""
"Znaczniki morfosyntaktyczne, tzw. tagi, przypisane są segmentom (tokenom,"
" w przybliżeniu słowom). Segmenty nie są dłuższe niż słowa ortograficzne "
"(słowa ‘od spacji do spacji’ z oddzieleniem znaków interpunkcyjnych), ale"
" w niektórych wypadkach segmenty mogą być krótsze niż takie słowa. "
"Szczegółowe zasady segmentacji dla poszczególnych języków mogą się różnić"
" i zależą od decyzji podjętych przez twórców zasobów jezykowych dla "
"danego języka (głównie twórców banków drzew zależnościowych) oraz przez "
"twórców konkretnych narzędzi programistycznych. Przykładowo, w korpusach "
"języka polskiego (w tym m.in. w Narodowym Korpusie Języka Polskiego) na "
"etapie segmentacji zwykło się oddzielać od form przeszłych czasowników "
"tzw. aglutynant (wykładnik osoby i liczby) a także partykułę *by* będącą "
"wykładnikiem trybu warunkowego. W efekcie jedno słowo tekstowe zostaje "
"rozbite odpowiednio na dwa lub trzy segmenty i każdemu z nich jest "
"przypisana osobna interpretacja fleksyjna: np. *[pisał][eś]*, "
"*[jedli][by][śmy]*. Jednak w Korpusomacie ta decyzja jest dodatkowo "
"zależna od wybranego potoku przetwarzania, bowiem twórcy tych potoków "
"podjęli w tej sprawie różne decyzje: Stanza stosuje segmentację taką, jak"
" w Narodowym Korpusie Języka Polskiego, czyli oddziela aglutynant i "
"partykułę *by*, ale spaCy uznaje formy czasu przeszłego oraz trybu "
"warunkowego za pojedyncze segmenty i nie rozbija ich. To jednak rzadkie i"
" skrajne przypadki wynikające ze specyfiki wykorzystanych narzędzi — w "
"większości wypadków teksty w poszczególnych językach powinny być "
"segmentowane w obu potokach tak samo i zgodnie z typową dla danego języka"
" segmentacją stosowaną w bankach drzew składniowych oraz korpusach "
"narodowych danych języków."
msgstr ""
"Morphosyntactic tags are attributed to tokens, which correspond roughly  "
"to words. A token cannot be longer than an orthographic word (separated "
"by spaces from other orthographic words, punctuation marks excluded), but"
" it may sometimes be shorter. Segmentation rules may be different for "
"different languages, and they depend on the decisions made by the "
"creators of language resources for a given language (mainly treebanks), "
"and by the creators of specific programming tools. For instance, in "
"Polish language corpora (including the Polish National Corpus), it is "
"customary to separate past verb forms from their so-called agglutinates "
"(markers of person and number), and from the marker of the conditional "
"mood (*by* particle). As a result, one word may be divided into two or "
"three component parts, and each of them is given its own morphosyntactic "
"tag. For example, the Polish verb *jedlibyśmy* (*we would be eating*) "
"would be separated into three different tokens: *[jedli][by][śmy]*, where"
" *jedli* is the main verb (*eat*), *by* is the marker of the conditional "
"mood, and *śmy* marks for the first person plural. In Korpusomat, the "
"results of the tokenisation process may differ depending on the selected "
"pipeline. Specifically, Stanza uses the same tokenisation model as is "
"employed in the Polish National Corpus (it separates the agglutinate and "
"the *by* particle), whereas spaCy considers past verb forms and "
"conditional forms to constitute discrete tokens. This, however, is a rare"
" and extreme case. Usually, the tokenisation of texts in a given language"
" should be in line with the models adopted in the treebanks and the "
"national corpora of this language, regardless of the pipeline employed."

#: ../../mtas.rst:17 43c7c60d10354fe894c058f7a4a1c752
msgid "Znaczniki morfosyntaktyczne"
msgstr "Morphosyntactic tags"

#: ../../mtas.rst:19 efbde9f9c70c4b7d8fabb137b294e009
msgid ""
"Wszystkie korpusy w Korpusomacie zawierają warstwę informacji "
"morfosyntaktycznej zgodną ze specyfikacją Universal Dependencies. "
"Informacja ta jest rozdzielona na dwie składowe: oznaczenie części mowy "
"(tzw. UPOS — *universal part of speech*) oraz cechy morfosyntaktyczne "
"(tzw. UFEATS — *universal features*). Obie te składowe (nazwy części "
"mowy, nazwy cech morfoskładniowych i listy ich możliwych wartości) są "
"opisane w dokumentacji `na stronie projektu UD "
"<https://universaldependencies.org/guidelines.html>`__. Ponieważ z zasady"
" jest to opis uniwersalny, każdy z konkretnych języków korzysta tylko z "
"podzbioru cech morfologicznych i ich wartości."
msgstr ""
"In Korpusomat, corpora are annotated morphosyntactically based on the "
"framework of Universal Dependencies. This layer of annotation has two "
"components: universal part-of-speech tagging (UPOS) and universal "
"(morphosyntactic) features (UFEATS). These two components (parts of "
"speech, morphosyntactic features, as well as lists of their possible "
"values) are described in more detail on the UD project website: "
"<https://universaldependencies.org/guidelines.html>`__. Because, in "
"principle, it is a universal description, only a subset of morphological "
"features and their values will apply to any particular language."

#: ../../mtas.rst:21 4b9c1692dbd94e0d83e5271be97e651a
msgid ""
"Oprócz informacji morfosyntaktycznej zgodnej ze specyfikacją UD w "
"większości korpusów dostępny jest również dodatkowy znacznik, tzn. XPOS, "
"który przechowuje informację morfosyntaktyczną zgodną z tagsetem "
"stosowanym w zasobach dla danego języka. Oba potoki przetwarzania znakują"
" teksty również znacznikami XPOS, ale ich konkretna postać zależy zarówno"
" od twórców narzędzi, jak i twórców banku drzew UD. W szczególności od "
"twórców banku drzew zależy, jaka postać znacznika znajdzie się w polu "
"XPOS — zarówno pod względem szczegółowości opisu morfosyntaktycznego, jak"
" i technicznego opisu samego tagsetu, dlatego nie mają one "
"ustandaryzowanej wspólnej postaci. Najczęściej są to jednak systemy "
"znaczników stosowane w narodowych korpusach tych języków. W wypadku gdy "
"twórcy banku drzew UD nie umieścili w nim znaczników XPOS, Korpusomat "
"również nie umożliwa korzystania z nich — tak jest wypadku języka "
"rosyjskiego (w obu potokach przetwarzania). W niektórych wypadkach postać"
" znacznika XPOS może się różnić w zależności od potoku przetwarzania, np."
" w wypadku języka polskiego Stanza zwraca pełne znaczniki "
"morfosyntaktyczne (w tagsecie stosowanym w polskich korpusach), spaCy zaś"
" ogranicza się tylko do pierwszej części takiego znacznika oznaczającej "
"przynależność słowa do klasy gramatycznej."
msgstr ""
"Alongside morphosyntactic annotation based on the UD framework, an "
"additional XPOS tag is available for most corpora. XPOS stores "
"morphosyntactic information in line with the tagset employed in resources"
" for a given language. Both pipelines return XPOS-tagged texts, but the "
"precise forms of the tags depend on the decisions made by the creators of"
" these specific tools and, in particular, by the creators of UD treebanks"
" (specifically, technical descriptions of the tagset and the granularity "
"of morphosyntactic descriptions may vary). As a result, XPOS tags do not "
"have a single, standardised form. Usually, however, they comply with the "
"tagsets employed in national corpora. If XPOS tags are not included in a "
"given UD treebank (as is the case of Russian), Korpusomat will not be "
"able to provide them (regardless of the pipeline employed). Sometimes, "
"XPOS tags may differ depending on the pipeline, e.g. for Polish, using "
"Stanza will return full morphosyntactic XPOS tags (as they are employed "
"in Polish corpora), whereas spaCy will reduce them to the component which"
" signals the grammatical class of the given word."

#: ../../mtas.rst:25 41ddcbd5ce85482e891b052b04510548
msgid "Język zapytań"
msgstr "Corpus Query Language"

#: ../../mtas.rst:27 dd1722cd0ea94488b498c956d44d15a1
msgid ""
"Składnia zapytań w programie MTAS została oparta na języku zapytań o "
"nazwie Corpus Query Language (CQL), który jest powszechnie znany i "
"stosowany w wyszukiwarkach korpusowych. Niniejszy rozdział omawia "
"składnię CQL w wariancie zastowanym w Korpusomacie."
msgstr ""
"The syntax of queries in MTAS in based on the Corpus Query Language "
"(CQL), used in many other corpus browsers. This section describes the CQL"
" as it is employed in Korpusomat."

#: ../../mtas.rst:31 de403951f63f456db3a41b70c10f7944
msgid ""
"MTAS jest uniwersalną wyszukiwarką pozwalającą na przeszukiwanie korpusów"
" zawierających wiele warstw anotacyjnych. Niniejsza instrukcja dotyczy "
"przeszukiwania korpusów postaci indeksowanej przez Korpusomat, który "
"tworzy aktualnie trzy warstwy znakowania: warstwę morfosyntaktyczną i "
"składniową oraz warstwę jednostek nazewniczych. Ogólna podstawowa "
"dokumentacja wyszukiwarki MTAS znajduje się `na jej stronie internetowej "
"<https://meertensinstituut.github.io/mtas/>`__."
msgstr ""
"MTAS is a multifunctional browser, ideal for corpora with many layers of "
"annotation. The following is a guide to querying corpora indexed in "
"Korpusomat, which are annotated at three different levels: "
"morphosyntactic, syntactic, and the level of named entities. More "
"general, basic information on MTAS is available at: "
"<https://meertensinstituut.github.io/mtas/>`__."

#: ../../mtas.rst:39 3dc9e7ea601841b799f02630ca83a317
msgid "Zapytania o segmenty"
msgstr "Searching for tokens"

#: ../../mtas.rst:41 5e601672e71042d7bb70e63f463c4a61
msgid ""
"Podstawową jednostką wyszukiwaną w korpusie jest segment. Segmenty w "
"zapytaniach są ograniczone nawiasami kwadratowymi, wewnątrz których można"
" określać konkretne cechy, które segment ma spełniać. W najprostszym "
"przypadku jest to kształt tekstowy (napis). Do zapytań o tę postać "
"ortograficzną segmentu służy atrybut ``orth``, można też jednak "
"ograniczyć się do wpisania w oknie wyszukiwarki poszukiwanego słowa (lub "
"słów). Zatem poniższe zapytanie o dwa sąsiadujące ze sobą segmenty:"
msgstr ""
"The most basic unit in a corpus search is a token (an orthographic word). Usually, each element of a query has to be enclosed in square brackets. You can specify that you are searching for a token by adding the attribute ``orth``. In this way, you can search for one or more (neighbouring) tokens. For example, the following query will return all instances where the words "green" and "ideas" appear next to each other (but it will not return those
instances where "green" modifies the singular noun "idea", or where the noun "ideas" is modified by adjectives such as "greener" or "greenish"):"

#: ../../mtas.rst:52 090f0349df494aafafef16477c65744b
msgid "[orth=\"komisja\"][orth=\"szkolna\"]"
msgstr ""
"[orth=\"green\"][orth=\"ideas\"]"

#: ../../mtas.rst:54 26649f7086f0441d8e2c5dfb55e7c283
msgid "można zadać również w prostszy sposób:"
msgstr "You can also search for tokens by simply typing them into the search box:"

#: ../../mtas.rst:58 8ddf9cc02a36415d9007139f735ba960
msgid "komisja szkolna"
msgstr "green ideas"

#: ../../mtas.rst:60 e18907985fa640fd81b5722cb424d1ec
msgid ""
"Domyślnie rozróżniana jest kasztowość (wielkość) liter, a zatem poniższe "
"dwa zapytania dadzą różne wyniki:"
msgstr ""
"By default, the tool distinguishes between lowercase and uppercase letters. As a result, the following queries will return different results:"

#: ../../mtas.rst:63 8ecf54d5f2dd4990b7b3988fc1b8a1db
msgid "``przyszedł``"
msgstr "``colorless``"

#: ../../mtas.rst:65 6365073c2dac467aaebb52a34295d3a4
msgid "``Przyszedł``"
msgstr "``Colorless``"

#: ../../mtas.rst:67 651ab0b588794658a13dc16a7925bd8b
msgid ""
"Dostępny jest jednak dodatkowy atrybut pomocniczy ``orth_lc`` (``lc`` od "
"ang. *lower case*) przechowujący postać ortograficzną segmentu z "
"zamienionymi literami wielkimi na małe. Dzięki temu można wyszukiwać "
"słowa zapisane w różny sposób bez konieczności odwoływania się do wyrażeń"
" regularnych. Na przykład zapytanie ``[orth_lc=\"przyszedł\"]`` zwróci "
"wystąpienia słów postaci *przyszedł* i *Przyszedł*, jak również "
"*PRZYSZEDŁ* czy *PRzySZedŁ*."
msgstr ""
"You can, however, use the attribute ``orth_lc`` (where ``lc`` stands for *lower case*) to change all uppercase letters in a token into lowercase letters. As a result, a query such as ``[orth_lc="colorless"]`` will return all instances of words such as *colorless*, *Colorless*, *COLORLESS*, and *COlorLESs*."

#: ../../mtas.rst:75 848d39610927476a9a9474ff738e7cb6
msgid ""
"W zapytaniach o segmenty mogą wystąpić standardowe wyrażenia regularne "
"wykorzystujące następujące znaki specjalne: ``?``, ``*``, ``+``, ``.``, "
"``,``, ``|``, ``,``, ``[``, ``]``, ``(,`` ``)`` oraz liczby naturalne "
"pisane cyframi arabskimi, np. ``0`` czy ``21``. Ponieważ formalny opis "
"wyrażeń regularnych wykracza poza ramy niniejszej instrukcji, ograniczymy"
" się tutaj do kilku przykładów, które powinny pozwolić użytkownikowi na "
"szybkie przyswojenie składni i znaczenia takich wyrażeń."
msgstr ""
"Queries may also be based on standard regular expressions, which employ special characters such as ``?``, ``*``, ``+``, ``.``, ``,``, ``|``, ``,``, ``[``, ``]``, ``(,`` ``)``, as well as natural numbers (written in Arabic numerals), e.g. ``0`` or ``21``. While a more formal description of regular expressions is beyond the scope of this guide, the following examples illustrate the most essential rules of their use."

#: ../../mtas.rst:86 60a3d0b414be4befb525cb06398e9c94
msgid "[orth=\"(Ala|Ela)\"]"
msgstr "[orth=\"(pal|gal)\"]"

#: ../../mtas.rst:88 9d26c26aacd142609f705f4cae0e7ca2
msgid ""
"znak ``|`` oznacza alternatywę dwóch wyrażeń (całość należy dodatkowo "
"ująć w nawiasy okrągłe), a zatem zapytanie to może zostać użyte do "
"znalezienia wszystkich wystąpień segmentów *Ala* lub *Ela*,"
msgstr ""
"``|`` is an equivalent to "or": it matches all instances of one of two tokens (which are placed inside round brackets), such as *gal* or *pal*,"

#: ../../mtas.rst:94 4dd22959dad44cd895efb7c580620e0d
msgid "[orth=\"[AE]la\"]"
msgstr "[orth=\"[gp]al\"]"

#: ../../mtas.rst:96 28daee26384e4df6b39b45c13e0bee7d
msgid ""
"nawiasy kwadratowe oznaczają alternatywę znaków, a zatem zapytanie to "
"może zostać użyte do znalezienia tych segmentów, których pierwszy znak to"
" *A* lub *E*, po którym następuje ciąg znaków postaci *la*, tj. zapytanie"
" to jest równoważne poprzedniemu,"
msgstr ""
"placing *p* and *g* inside square brackets, followed by *al*, will return all instances of words beginning with either *p* or *g*, followed by *al*, in the exact same manner as the query above,"

#: ../../mtas.rst:103 6d13085c35234b2ab121bcb8efad44cb
msgid "[orth=\"beza?\"]"
msgstr "[orth=\"gall?\"]"

#: ../../mtas.rst:105 63f01b6498ff4036b97035fdd4cb7487
msgid ""
"znak zapytania oznacza opcjonalność znaku (tutaj ostatniego *a*) lub "
"ujętego w nawiasy okrągłe wyrażenia bezpośrednio poprzedzającego znak "
"``?``, a zatem w wyniku zadania tego zapytania znalezione zostaną "
"segmenty *bez* i *beza*,"
msgstr ""
"``?`` makes the element it follows (or a group of elements placed inside round brackets) optional. The above query will return all instances of *gal* and *gall*,"

#: ../../mtas.rst:112 b22a2d354f7c410a95364053e14dd34b
msgid "[orth=\"bez.\"]"
msgstr "[orth=\"gal.\"]"

#: ../../mtas.rst:114 88b362fbe06542ad9f04785baa0dba62
msgid ""
"kropka oznacza dowolny znak, a zatem wynikiem tego zapytania będą "
"segmenty *beza*, *bezy*, *bezą* itp., ale nie *bez* czy *bezami*,"
msgstr ""
"full stop substitutes for one character only. This query will return all instances of tokens such as *gall*, *gale*, *gala*, *gals*, but not *gal* or *galled*,"

#: ../../mtas.rst:119 2649c9c4a66349c2b7054e2c608cda56
msgid "[orth=\"bez.?\"]"
msgstr "[orth=\"gal.?\"]"

#: ../../mtas.rst:121 ff4fb553b2074fd688c3946879312f90
msgid "*bez*, *beza*, *bezy*, *bezą* itp., ale nie *bezami*,"
msgstr ""
"*gal*, *gals*, *gale*, *gala*, *gall*, but not *galled*,"

#: ../../mtas.rst:125 d97d45d7142840e4a11227480b374d34
msgid "[orth=\".z.z.\"]"
msgstr "[orth=\"t.t..\"]"

#: ../../mtas.rst:127 7f5f4ae109f746279c36b6d6f6a4668f
msgid ""
"segmenty pięcioznakowe, w których 2. i 4. znak to *z* (np. *czczą* i "
"*rzezi*),"
msgstr ""
"tokens with five characters, where *t* is the first and third character (e.g. *tutor*, *totem*, *total*),"

#: ../../mtas.rst:132 e98f4bafcd5f48ccb93fb3702a65d1e5
msgid "[orth=\"a*by\"]"
msgstr "[orth=\"w*i\"]"

#: ../../mtas.rst:134 ca361005b7d04757b9d920721c89ca3e
msgid ""
"gwiazdka oznacza dowolną liczbę wystąpień znaku lub wyrażenia "
"bezpośrednio przed nią, a zatem zapytanie to może posłużyć do znalezienia"
" segmentów składających się z dowolnej liczby liter *a*, po których "
"następuje ciąg *by*, np. *by* (zero wystąpień *a*), *aby*, *aaaaby* itp.,"
msgstr ""
"asterisk repeats the preceding character or a group of characters any number of times. For instance, we can use it to search for tokens consisting of the letter *w* followed by zero or more letters *i*, such as *w*, *wi*, *wii*, *wiii*, etc.,"

#: ../../mtas.rst:142 2fa29932c6d74eda914cd16a8aefd416
msgid "[orth=\"Ala.*\"]"
msgstr "[orth=\"gal.*\"]"

#: ../../mtas.rst:144 6733c85a60044339b15c9a29e269e3fc
msgid "segmenty zaczynające się na *Ala*, np. *Ala* i *Alabama*,"
msgstr "tokens beginning with *gal*, such as *gal* or *gallery*,"

#: ../../mtas.rst:148 7ca72cf3dbdb498198ed3147fab4073b
msgid "[orth=\".*al+\"]"
msgstr "[orth=\".*al+\"]"

#: ../../mtas.rst:150 2576a96107cc40d099ea78a3fe3127fe
msgid ""
"plus ma działanie podobne do gwiazdki i oznacza dowolną większą od zera "
"liczbę wystąpień znaku lub wyrażenia bezpośrednio przed nim, a zatem "
"wynikiem tego zapytania będzie znalezienie segmentów kończących się na "
"*al*, *all*, *alll* itd., ale nie na *a*, np. *dal*, *robal* i *Gall*,"
msgstr ""
"the plus sign has a similar function: it repeats the preceding character or a group of characters any number of times higher than zero. The above query will return tokens which end in *al*, *all*, *alll*, etc., but not in *a*, for example *gal*, *regal*, or *gall*,"

#: ../../mtas.rst:158 70f2a0d687054020bc4d64d8bc833c67
msgid "[orth=\"a{1,3}b.*\"]"
msgstr "[orth=\"wi{1,3}.*\"]"

#: ../../mtas.rst:160 85b06c0edff04c70a3ed62bdd59c6a62
msgid ""
"konstrukcja typu ``n,m`` oznacza od ``n`` do ``m`` wystąpień znaku lub "
"wyrażenia bezpośrednio przed nią, a zatem zapytanie to pomoże znaleźć "
"segmenty zaczynające się od ciągu od 1 do 3 liter a, po którym następuje "
"litera b, a następnie dowolny ciąg znaków (por. ``.*``), np. *aby*, "
"*aaaby*, *absolutnie*,"
msgstr ""
"*w* is followed by between 1 and 3 letters *i*, which are then followed by any number of characters. The results might include tokens such as *wi*, *wii*, and *winter*,"

#: ../../mtas.rst:168 018f84a4c48f47bdbe9481d4084b16db
msgid "[orth=\".*(la){3,}.*\"]"
msgstr "[orth=\".*(ha){3,}.*\"]"

#: ../../mtas.rst:170 a347f30ead384e12a7acdf559a491065
msgid ""
"konstrukcja typu ``n,`` oznacza co najmniej ``n`` wystąpień znaku lub "
"ujętego w nawiasy okrągłe wyrażenia bezpośrednio przed nią, a zatem "
"zapytanie to może posłużyć do znalezienia segmentów, w których ciąg *la* "
"występuje przynajmniej 3 razy z rzędu, np. *tralalala*, *sialalala*,"
msgstr ""
"``n,`` repeats the preceding character or a group of characters (placed inside square brackets) at least n times. For example, the above query will return tokens where *ha* is repeated at least three times, such as *ahahaha* or *hahahaha*,"

#: ../../mtas.rst:178 8df5f3a9dcb94751b68581b2edb37e7e
msgid "Zapytania z innymi atrybutami"
msgstr "Queries with different attributes"

#: ../../mtas.rst:180 ada3850e44004782b761bed0a1d78dbc
msgid ""
"Aby znaleźć wszystkie formy leksemu *korpus*, można użyć następującego "
"zapytania:"
msgstr "In order to find all forms of the word *corpus*, type in the following query:"

#: ../../mtas.rst:185 d76eef00d95e43d2a8bfa2e223de3387
msgid "[lemma=\"korpus\"]"
msgstr "[lemma=\"corpus\"]"

#: ../../mtas.rst:187 ffd11c4177b547898ee9df6af8871831
msgid ""
"Atrybut ``lemma`` jest jednym z wielu, jakie mogą pojawić się w "
"zapytaniu. Wartością tego atrybutu powinna być forma podstawowa "
"(hasłowa), a zatem zapytanie ``[lemma=\"pisać\"]`` może być użyte do "
"znalezienia form typu *pisać*, *piszę*, *pisała*, *piszcie*, *pisanie*, "
"*pisano*, *pisane* itp."
msgstr ""
"``lemma`` is one of the many attributes which may form part of a query. It takes the basic, dictionary form of a word as its value. For instance, ``[lemma="sleep"]`` will return forms such as *sleep*, *slept*, and *sleeping*."

#: ../../mtas.rst:193 134ddbe015f144ea906635b03ada743a
msgid ""
"Podobnie jak w wypadku atrybutu ``orth`` wartościami atrybutu ``lemma`` "
"mogą być wyrażenia regularne, np:"
msgstr ""
"Similarly as in the case of the attribute ``orth``, regular expressions may be used to form queries about lemmas. For example, the following"

#: ../../mtas.rst:198 0ab5a78e007649f18190ce909194d0cd
msgid "[lemma=\"komit[ae]t\"]"
msgstr "[lemma=\"p[ao]tent\"]"

#: ../../mtas.rst:200 408a86ce9d29424280a3d224930fecc2
msgid ""
"znalezione zostaną wszystkie segmenty, których forma hasłowa ma postać "
":lex:`komitet` lub :lex:`komitat`."
msgstr ""
"will return all instances of tokens whose dictionary forms (lemmas) are either :lex:`patent` or :lex:`potent`."

#: ../../mtas.rst:203 4c78d39935504748ab7d4a5832d751de
msgid ""
"Zapytania o różne atrybuty segmentów można łączyć. Na przykład, aby "
"znaleźć wszystkie wystąpienia segmentu *minę* rozumianego jako forma "
"leksemu :lex:`mina` (a nie na przykład leksemu :lex:`minąć`), można zadać"
" następujące zapytanie:"
msgstr ""
"You can also specify more than one attribute of your search item. For instance, if you wish to find all instances of the token *cooler*, but only in its adjectival meaning (i.e. the comparative form of the adjective *cool*), but you want to exclude those instances where *cooler* is used as a noun, the following query may be employed:"

#: ../../mtas.rst:210 edbf72a3a9eb4dd98fedbed46485edf6
msgid "[orth=\"minę\" & lemma=\"mina\"]"
msgstr "[orth=\"cooler\" & lemma=\"cool\"]"

#: ../../mtas.rst:212 471daf2565604e78b5ccf0b2f9b5d2e6
msgid ""
"Podobne znaczenie ma następujące zapytanie o te wystąpienia segmentu "
"*minę*, które nie są interpretowane jako formy leksemu :lex:`minąć`."
msgstr ""
"The following query, which instead excludes those instances where *cooler* is used as a noun, will return similar results:"

#: ../../mtas.rst:217 00f938484cf141f492988cd00d98c2e2
msgid "[orth=\"minę\" & !lemma=\"minąć\"]"
msgstr "[orth=\"cooler\" & !lemma=\"cooler\"]"

#: ../../mtas.rst:219 b2ce5120de0f43d78a1900eec91023bc
msgid ""
"W powyższych zapytaniach operator ``&`` spełnia rolę logicznej "
"koniunkcji. Operatorem do niego dualnym jest operator ``|``, spełniający "
"rolę logicznej alternatywy. Oto kilka przykładów użycia tego operatora:"
msgstr ""
"While ``&`` is the operator of logical conjunction, a disjunctive formula is notated with ``|``. Here are some examples of how the latter can be employed:"

#: ../../mtas.rst:225 e1d77385becb47e09e0bd25815acd63b
msgid "[lemma=\"on\" | lemma=\"ja\"]"
msgstr "[lemma=\"sleep\" | lemma=\"dream\"]"

#: ../../mtas.rst:227 36fd8c90a82c48ae95547a4928a4e13e
msgid ""
"wszystkie formy zaimków :lex:`on` i :lex:`ja`, równoważne zapytaniu "
"``[lemma=\"on|ja\"]``,"
msgstr ""
"returns all forms of the verbs :lex:`sleep` and :lex:`dream`; this query is equivalent to ``[lemma="sleep|dream"]``,"

#: ../../mtas.rst:232 8bc8a14bec174e72bcb3f3bc7ea44d0b
msgid "[lemma=\"on\" | orth=\"mnie\" | orth=\"ciebie\"]"
msgstr "[lemma=\"sleep\" | orth=\"dreaming\" | orth=\"dreamer\"]"

#: ../../mtas.rst:234 1c4e88a4949f4f62ada71e1f774b1ba7
msgid "wszystkie formy zaimka :lex:`on`, a także segmenty *mnie* i *ciebie*,"
msgstr ""
"returns all forms of the verb :lex:`sleep`, as well as all instances of the segments *dreaming* and *dreamer*,"

#: ../../mtas.rst:238 fdec3c01a1c14620be3e38f149a8a654
msgid "[orth=\"pora\" & !(lemma=\"por\" | lemma=\"pora\")]"
msgstr "[orth=\"cooler\" & !(lemma=\"cool\" | lemma=\"cooler\")]"

#: ../../mtas.rst:240 a90cd92a0c8649e69ff60e20544d190f
msgid ""
"segment *pora* niebędący ani formą leksemu :lex:`por`, ani formą leksemu "
":lex:`pora`."
msgstr ""
"returns all instances of the token *cooler* which are neither forms of the lexeme :lex:`cool`, nor forms of the lexeme :lex:`cooler`."

#: ../../mtas.rst:243 aec0efeccedf49cba05e31d87e679680
msgid ""
"Aby lepiej zrozumieć różnicę pomiędzy operatorami ``&`` i ``|``, "
"porównajmy następujące dwa zapytania:"
msgstr ""
"In order to better understand the difference between the two operators - ``&`` and ``|`` - let us compare the following two queries:"

#: ../../mtas.rst:248 363583462eca4376ac29659b46a863ea
msgid ""
"[orth=\"minę\" & lemma=\"mina\"]\n"
"[orth=\"minę\" | lemma=\"mina\"]"
msgstr ""
"[orth=\"cooler\" & lemma=\"cool\"]\n"
"[orth=\"cooler\" | lemma=\"cool\"]"

#: ../../mtas.rst:251 2c9861861e3c428598cd388eb980cdf7
msgid ""
"W wyniku zadania pierwszego zapytania znalezione zostaną te segmenty, "
"które są jednocześnie (koniunkcja) segmentem *minę* i formą leksemu "
":lex:`mina`, a więc wyłącznie te wystąpienia segmentu *minę*, które są "
"interpretowane jako formy leksemu :lex:`mina`. W wyniku zadania drugiego "
"zapytania znalezione natomiast zostaną te segmenty, które są albo "
"dowolnie interpretowanym segmentem *minę*, albo formą leksemu :lex:`mina`"
" (alternatywa), czyli wszystkie wystąpienia zarówno segmentu *minę*, jak "
"i segmentów *mina*, *miny*, *minami* itp. interpretowanych jako formy "
"leksemu :lex:`mina`."
msgstr ""
"The first query matches only tokens which are interpreted as forms of the lexeme :lex:`cool`. The second query matches all tokens of the word *cooler*, regardless of their interpretation (noun or adjective), as well as all forms of the lexeme :lex:`cool`, such as, among others *cooling*, *coolest*, and *coolers*."

#: ../../mtas.rst:261 739384c5c5ca400c8950f67338aafe2c
msgid ""
"Specyfikacje pozycji w korpusie, ujęte w nawiasy kwadratowe, mogą "
"zawierać dowolną liczbę warunków typu ``atrybut=\"wartość\"`` (na "
"przykład ``orth=\"nie\"``) połączonych operatorami ``!``, ``&`` i ``|``, "
"tak jak pokazują to powyższe przykłady. Możliwe jest także całkowite "
"pominięcie jakichkolwiek warunków. Poniższe zapytanie mogłoby posłużyć do"
" znalezienia wszystkich segmentów w korpusie."
msgstr ""
"A query may include as many attributes (with their values) as necessary, which may be connected using operators such as ``!``, ``&``, and ``|``, as the examples above demonstrate. But a query without any conditions is also possible. The following query may be used to retrieve all tokens in the corpus."

#: ../../mtas.rst:270 f496128d3b1f42e283c8157b63bdd17f
msgid "[]"
msgstr "[]"

#: ../../mtas.rst:272 121dc4d20a5842ce8251d2bfe122060e
msgid ""
"Taka „pusta” specyfikacja pozycji w korpusie, pasująca do dowolnego "
"segmentu, może posłużyć na przykład do znalezienia dwóch form "
"oddzielonych od siebie dowolnymi dwoma segmentami, np.:"
msgstr ""
"In other words, empty square brackets stand for any token. They can be used, for instance, to retrieve two specific tokens, which are separated by two unspecified tokens:"

#: ../../mtas.rst:278 8be7e59335b94821bc78b5c61b5e2c29
msgid "[orth=\"się\"][][][lemma=\"bać\"]"
msgstr "[orth=\"you\"][][][lemma=\"sleep\"]"

#: ../../mtas.rst:280 7715be60e3254f739321f81b17447158
msgid ""
"W wyniku tego zapytania zostaną znalezione ciągi takie jak *się mnie też "
"bać* czy *się nie chcę bać*."
msgstr ""
"This will retrieve multi-word items such as *you can always sleep* or *you and I sleep*."

#: ../../mtas.rst:283 bc432e271c25492d8a0d57c52ea8a10d
msgid ""
"Dla wielu zastosowań ciekawsza byłaby możliwość zapytania na przykład o "
"formy oddalone od siebie o najwyżej pięć pozycji. MTAS umożliwia "
"zadawanie takich pytań, gdyż pozwala na formułowanie wyrażeń regularnych "
"także na poziomie pozycji korpusu. Na przykład zapytanie o formę leksemu "
":lex:`bać` występującą dwie, trzy lub cztery pozycje dalej niż forma "
"*się* może wyglądać następująco:"
msgstr ""
"You can also search for two tokens which are separated by up to n unspecified tokens. For example, the following query will return multi-word expressions, where *you* is separated from *sleep* by two, three, or four unspecified tokens:"

#: ../../mtas.rst:292 f3c9153c40034caabcd88ac0acdf5f1e
msgid "[orth=\"się\"][]{2,4}[lemma=\"bać\"]"
msgstr "[orth=\"you\"][]{2,4}[lemma=\"sleep\"]"

#: ../../mtas.rst:294 fa2d7d4c2b5b46d191169e53bb56394e
msgid ""
"W wyniku tego zapytania zostaną znalezione ciągi uzyskane w wyniku "
"poprzedniego zapytania, a także na przykład ciąg *się pani niczego nie "
"boi*."
msgstr ""
"The results will include expressions retrieved using the preceding query (*you can always sleep* and *you and I sleep*), as well as others, such as *you can go to sleep* or *you and I will sleep*."

#: ../../mtas.rst:298 b1556698e832403ba0922c7f3fa05639
msgid ""
"Zapewne nieco bardziej precyzyjnym zapytaniem o różne wystąpienia form "
"tzw. czasownika zwrotnego :lex:`bać się` byłoby zapytanie o *się* w "
"pewnej odległości przed formą leksemu :lex:`bać`, ale bez znaku "
"interpunkcyjnego pomiędzy tymi formami, lub bezpośrednio za taką formą, "
"ewentualnie oddzielone od formy bać zaimkiem osobowym:"
msgstr ""

#: ../../mtas.rst:306 a4f2b782426f4755b780cae907a26160
msgid ""
"[orth=\"się\"][!orth=\"[.!?,:]\"]{0,5}[lemma=\"bać\"] | "
"[lemma=\"bać\"][lemma=\"on|ja|ty|my|wy\"]?[orth=\"się\"]"
msgstr ""

#: ../../mtas.rst:310 ad7e470c70b143bca578313c659d21ac
msgid "Zapytania o znaczniki morfosyntaktyczne"
msgstr ""

#: ../../mtas.rst:312 d75c5ad4fe7d460b8346b2e13dd1ff35
msgid ""
"Powyższe zapytanie można uprościć poprzez zastąpienie warunku "
"``orth!=\"[.!?,:]\"`` bezpośrednim odwołaniem do „części mowy” ``PUNCT``:"
msgstr ""

#: ../../mtas.rst:318 90c472f71b19478c9066ffac3c9993a3
msgid ""
"[orth=\"się\"][!upos=\"PUNCT\"]{0,5}[lemma=\"bać\"] | "
"[lemma=\"bać\"][lemma=\"on|ja|ty|my|wy\"]?[orth=\"się\"]"
msgstr ""

#: ../../mtas.rst:320 19ef0fd63df942688d81b757fdbac81b
msgid ""
"Ogólniej, wartościami atrybutu ``upos`` (*universal part of speech*) są "
"skróty nazw klas gramatycznych `omówionych w dokumentacji Universal "
"Dependencies <https://universaldependencies.org/u/pos/index.html>`__. Na "
"przykład zapytanie o sekwencję dwóch form rzeczownikowych "
"rozpoczynających się na *a* może być sformułowane w sposób następujący:"
msgstr ""

#: ../../mtas.rst:327 0fd8b0e8b89a4fffa17df2693967f1f7
msgid "[upos=\"NOUN\" & orth=\"a.*\"]{2}"
msgstr ""

#: ../../mtas.rst:329 ba6ecb9a2bca4e988dfafd03967dbc49
msgid ""
"Podobnie jak to miało miejsce w wypadku specyfikacji form obu warstw "
"tekstowych i form hasłowych, także specyfikacje klas gramatycznych mogą "
"zawierać wyrażenia regularne."
msgstr ""

#: ../../mtas.rst:333 4b1123b9f7e14bdc85f3a23e8cdeba4d
msgid ""
"Dodatkowo za pomocą atrybutu ``xpos`` można odwołać się w zapytaniu do "
"znacznika specyficznego dla języka. Specyfikacja tego atrybutu również "
"może zawierać wyrażenia regularne. Na przykład w korpusie stworzony w "
"języku czeskim następujące zapytanie:"
msgstr ""

#: ../../mtas.rst:339 59ddb714c78d4d2da2678565c1cc1bf3
msgid "[xpos=\"NNNS1.*\"]"
msgstr ""

#: ../../mtas.rst:341 fce58cf9033d417ea4b8ff17a26a379d
msgid ""
"wyszuka wszystkie rzeczowniki w rodzaju nijakim w mianowniku liczby "
"pojedynczej. Rzeczowniki o tych samych cechach w polskim korpusie (w "
"potoku Stanzy) znajdzie zapytanie:"
msgstr ""

#: ../../mtas.rst:346 ac1949df54ba4604b87ede6535704c00
msgid "[xpos=\"subst:sg:nom:n.*\"]"
msgstr ""

#: ../../mtas.rst:348 65a4777a16f847b9b300fc89a31e79af
msgid ""
"W obu wypadkach wartość atrybutu ``xpos`` jest zakończona wyrażeniem "
"``.*``, ponieważ po wartościach części mowy, liczby, rodzaju i przypadka "
"mogą pojawić się jeszcze wartości innych kategorii uwzględnionych w obu "
"tagsetach."
msgstr ""

#: ../../mtas.rst:353 a2204a84cfed48b4a4647670646901bd
msgid ""
"W zapytaniach można określić nie tylko postać ortograficzną segmentu (za "
"pomocą atrybutu ``orth``), formę hasłową (za pomocą ``lemma``) i klasę "
"gramatyczną (za pomocą ``upos`` lub ewentualnie ``xpos``), ale także "
"wartości poszczególnych kategorii gramatycznych, np. przypadka czy "
"rodzaju — o ile te kategorie występują w danym języku. W korpusach danego"
" języka można używać atrybutów o nazwie kategorii obecnych w banku drzew "
"zależnościowych w warstwie cech morfosyntaktycznych (UFEATS) dla tego "
"języka. Listę wszystkich kategorii można znaleźć `na stronie Universal "
"Dependencies <https://universaldependencies.org/u/feat/all.html>`__."
msgstr ""

#: ../../mtas.rst:361 aad39d2f63a7468c9a27f90b13d5e704
msgid ""
"A zatem w korpusach dla języków posiadających liczbę gramatyczną możliwe "
"jest zadanie na przykład następujących zapytań:"
msgstr ""

#: ../../mtas.rst:365 3bc2ccd5edf344c89b6372de331b6649
msgid "[number=\"sing\"]"
msgstr ""

#: ../../mtas.rst:367 b08bc13c1ba643dda815a4c18b583849
msgid "znalezione zostaną wszystkie formy w liczbie pojedynczej,"
msgstr ""

#: ../../mtas.rst:371 ba2dc19e6a3d4e4e99ba330f2a0d60da
msgid "[upos=\"NOUN\" & number=\"sing\"]"
msgstr ""

#: ../../mtas.rst:373 706eb09981a14589944cad9ccc44bd9a
msgid "znalezione zostaną formy rzeczowników pospolitych w liczbie pojedynczej,"
msgstr ""

#: ../../mtas.rst:377 1c9d08d7285b4b42b41b8f50817967f5
msgid "[upos=\"NOUN\" & !gender=\"fem\"]"
msgstr ""

#: ../../mtas.rst:379 3dd330488aa6479b8fdcfc6e3c147dc8
msgid ""
"formy rzeczowników pospolitych w rodzaju innym niż żeński (czyli np. dla "
"polskiego, czeskiego czy ukraińskiego: w rodzaju męskim lub nijakim),"
msgstr ""

#: ../../mtas.rst:383 f33552d7ed4f43b6b5ea32fbb3d7cc53
msgid "[number=\"sing\" & case=\"(nom|acc)\" & gender=\"masc\"]"
msgstr ""

#: ../../mtas.rst:385 5d57448a6376487f92f5f1251286106b
msgid ""
"pojedyncze mianownikowe lub biernikowe formy męskie (jeśli w języku są "
"kategorie liczby, przypadka i rodzaju)."
msgstr ""

#: ../../mtas.rst:387 bac1eca17ce24682bd06575d76c63c88
msgid ""
"Można również stosować zbiorczy atrybut ``ufeat`` w zastępstwie każdej "
"innej nazwy kategorii. Ujednoznacznienie dokona się przez odpowiednią "
"wartość. Dlatego następujące dwa zapytania zwrócą te same wyniki:"
msgstr ""

#: ../../mtas.rst:394 9e79627e05444cf5b51b547fc30e2189
msgid "[upos=\"NOUN\" & case=\"acc\" & number=\"plur\" & gender=\"fem\"]"
msgstr ""

#: ../../mtas.rst:398 9352268d8a7642d386d28e6b8094db38
msgid "[upos=\"NOUN\" & ufeat=\"acc\" & ufeat=\"plur\" & ufeat=\"fem\"]"
msgstr ""

#: ../../mtas.rst:402 3a9254f1fe2e4f9d968d374d3697fe69
msgid "Graficzny konstruktor zapytań"
msgstr ""

#: ../../mtas.rst:404 0246df1bc56449c693ffc8344bb30be3
msgid ""
"Do tworzenia podstawowych zapytań o sekwencje segmentów można użyć "
"prostego graficznego konstruktora. W oknie konstruktora można definiować "
"warunki określające cechy kolejnych segmentów zapytania, np. część mowy "
"(UPOS), postać segmentu w obu warstwach tekstowych, formę hasłową, a "
"także wartości wszystkich kategorii gramatycznych opisanych w "
"`dokumentacji UD <https://universaldependencies.org/u/feat/all.html>`__. "
"Poszczególne warunki w obrębie segmentu mogą być łączone operatorami "
"*oraz* (koniunkcja) i *lub* (alternatywa). Po zdefiniowaniu wszystkich "
"segmentów zapytania należy wcisnąć przycisk *Zapisz*, następnie określić "
"dodatkowe parametry wyszukania, np. ograniczenia za pomocą metadanych, i "
"rozpocząć wyszukiwanie. Zbudowane za pomocą konstruktora zapytania pojawi"
" się w pasku wyszukiwania, dzięki czemu można dodatkowo zweryfikować jego"
" poprawność."
msgstr ""

#: ../../mtas.rst:418 0030603990c7421183da5661b933311e
msgid "Ograniczenie zapytania do zdania lub akapitu"
msgstr ""

#: ../../mtas.rst:420 94d84416f4734deeab8c7ef9ad6f5b6c
msgid ""
"Jednostkami organizacji tekstu w korpusach indeksowanych przez Korpusomat"
" są zdania i akapity. Podział ten można wykorzystać w zapytaniach, na "
"przykład ograniczając dopasowanie do jednego zdania."
msgstr ""

#: ../../mtas.rst:424 74fe540b645b4545b07a5c871428add6
msgid ""
"Aby ograniczyć zasięg zapytania, należy dopisać do zapytania słowo "
"kluczowe ``within``, a po nim ``<s/>`` lub ``<p/>``, w zależności od "
"tego, czy zasięg ma być ograniczony do zdania (ang. *sentence*) czy do "
"akapitu (ang. *paragraph*). Ilustruje to następujący przykład zapytania o"
" zdania, w których forma *się* występuje za formą leksemu :lex:`być`, w "
"odległości co najmniej jednego i nie więcej niż dziesięciu segmentów:"
msgstr ""

#: ../../mtas.rst:433 e59213b8ffad4cb68c24e3adecd1335e
msgid "[lemma=\"bać\"][!orth=\"się\"]{1,10}[orth=\"się\"] within <s/>"
msgstr ""

#: ../../mtas.rst:435 9a3f589fd68f41c79f7bf655d34929d1
msgid ""
"Dodatkowo można również na elementy ``<s/>`` i ``<p/>`` nałożyć pewne "
"warunki dotyczące tego, czy zawierają segmenty innego typu. Przykładowo, "
"za pomocą następującego zapytania można znaleźć wszystkie wystąpienia "
"czasownika pomocniczego :lex:`być` w czasie przyszłym ograniczone do zdań"
" zawierających formę bezokolicznika:"
msgstr ""

#: ../../mtas.rst:443 a73f4f6c041b41d5a0bc03a5f7c95ba5
msgid ""
"[upos=\"AUX\" & lemma=\"być\" & tense=\"fut\"] within (<s/> containing "
"[verbform=\"inf\"])"
msgstr ""

#: ../../mtas.rst:445 4e8a88204fc04af7893f3565df20ef8e
msgid ""
"Intencją takiego zapytania jest odnalezienie (w przybliżeniu) wszystkich "
"wystąpień konstrukcji czasu przyszłego złożonego, w których pojawia się "
"bezokolicznik. Wśród wyników będą oczywiście również takie zdania, w "
"których czas przyszły został utworzony z użyciem formy przeszłej "
"czasownika, a bezokolicznik pełni w zdaniu inną funkcję gramatyczną. "
"Można też sformułować zapytanie odwrotnie i zapytać o zdania, w których "
"forma przeszła w ogóle nie występuje:"
msgstr ""

#: ../../mtas.rst:455 5f7712283d3b420f945c56aef090fff9
msgid ""
"[upos=\"AUX\" & lemma=\"być\" & tense=\"fut\"] within (<s/> !containing "
"[tense=\"past\"])"
msgstr ""

#: ../../mtas.rst:457 8add4589d2e64445a6d578de34ac6b11
msgid ""
"Pełną listę słów kluczowych, które mogą się pojawić w zapytaniach "
"wyszukiwarki MTAS, można znaleźć w jej `dokumentacji "
"<https://meertensinstituut.github.io/mtas/search_cql.html>`__, nie "
"wszystkie jednak będą miały sensowne zastosowanie w Korpusomacie."
msgstr ""

#: ../../mtas.rst:462 a9f4570507ae48e293e9573705b62c56
msgid ""
"Oprócz znaczników odnoszących się do elementów struktury tekstu (np. "
"``<s/>``) istnieją również znaczniki odnoszące się do ich początku i "
"końca. W wypadku ``<s/>`` będą to odpowiednio: ``<s>`` i ``</s>``. Ich "
"dopasowaniem nie jest żaden segment, ale mogą być użyte w połączeniu z "
"warunkami definiującymi inne segmenty, np. zapytanie:"
msgstr ""

#: ../../mtas.rst:470 3a06cd40a38945f9b859e4000d7ea12d
msgid "<s> [upos=\"NUM\"]"
msgstr ""

#: ../../mtas.rst:472 207a7dc89a0c48d591a767ec29ddedd5
msgid ""
"odnajdzie wszystkie wystąpienia liczebnika stojącego na początku zdania. "
"Analogicznie zapytanie:"
msgstr ""

#: ../../mtas.rst:477 0adc6db774574bbdb4f4845a8b86a8c3
msgid "[upos=\"NUM\"][upos=\"PUNCT\"]</s>"
msgstr ""

#: ../../mtas.rst:479 73a941a5a25b46958ff3da748e24d9c0
msgid ""
"odnajdzie wszystkie wystąpienia ciągu składającego się z liczebnika i "
"znaku interpunkcyjnego stojących na końcu zdania."
msgstr ""

#: ../../mtas.rst:483 05eb382ba434448aa3745b9e341714d9
msgid "Warstwa składniowa"
msgstr ""

#: ../../mtas.rst:485 4c076ac3dc50462c8bc265bf45e212eb
msgid ""
"Kolejną warstwą znakowania w Korpusomacie jest parsowanie zależnościowe. "
"Wprowadzony przez użytkownika tekst jest automatycznie dzielony na "
"wypowiedzenia, które z kolei są poddawane pełnej analizie składniowej w "
"aparacie zależnościowym według zasad przyjętych w `projekcie Universal "
"Dependencies <https://universaldependencies.org>`__. Przykład takiej "
"analizy znajduje się na poniższym rysunku."
msgstr ""

#: ../../mtas.rst:-1 6cca2d499cea4ed6a24f2db64fe69f8e
msgid "Rozbiór składniowy przykładowego zdania"
msgstr ""

#: ../../mtas.rst:495 5fdd297710604e2c9e727f5a8ad833d8
msgid ""
"MTAS nie jest wyszukiwarką struktur składniowych, nie pozwala zatem na "
"indeksowanie i przeszukiwanie pełnych rozbiorów zdań. Jednak na poziomie "
"każdego segmentu w tekście Korpusomat indeksuje informację o jego "
"bezpośrednim nadrzędniku składniowym (tzn. jego formie hasłowej i klasie "
"fleksyjnej) oraz o typie relacji zależności łączącej oba te elementy w "
"wypowiedzeniu. Ponadto indeksuje również ich położenie względem siebie w "
"wypowiedzeniu: kolejność w porządku linearnym oraz odległość (liczoną w "
"segmentach). Pozwala to na łatwe wyszukanie w korpusie prostszych "
"konstrukcji składniowych oraz analitycznych nieciągłych form fleksyjnych."
msgstr ""

#: ../../mtas.rst:506 34567d5246c7457887acecd4e2a2ab8c
msgid "W warstwie znakowania składniowego dostępne są następujące atrybuty:"
msgstr ""

#: ../../mtas.rst:508 6464e6eb5137416e92062253de804387
msgid ""
"``deprel`` — typ zależności, jaką dany segment jest związany ze swoim "
"bezpośrednim nadrzędnikiem składniowym; wartością tego atrybutu może być "
"jedna z 65 relacji zależności przewidzianych w `specyfikacji Universal "
"Dependencies <https://universaldependencies.org/u/dep/index.html>`__ (nie"
" wszystkie muszą jednak wystąpić w rozbiorach zdań w każdym języku),"
msgstr ""

#: ../../mtas.rst:512 6dafb3efc71e48bca3e69b46edebba2f
msgid "``head.upos`` — część mowy (UPOS) bezpośredniego nadrzędnika segmentu,"
msgstr ""

#: ../../mtas.rst:514 a9f21b789f33474a977921856e302ea4
msgid "``head.lemma`` — forma hasłowa bezpośredniego nadrzędnika segmentu,"
msgstr ""

#: ../../mtas.rst:516 2acb934054184237a5b9f2543dbb7fc1
msgid ""
"``head.ufeat`` — wartość dowolnej cechy morfologicznej bezpośredniego "
"nadrzędnika segmentu,"
msgstr ""

#: ../../mtas.rst:518 ae961261e7154b9f8bd430a39c693a06
msgid "``head.distance`` — odległość bezpośredniego nadrzędnika segmentu,"
msgstr ""

#: ../../mtas.rst:520 2f408915c982499abedf2ed672093948
msgid ""
"``head.position`` — położenie (lewo- lub prawostronne) bezpośredniego "
"nadrzędnika względem segmentu w porządku linearnym wypowiedzenia."
msgstr ""

#: ../../mtas.rst:523 9fe0fd96d0834727b215699fa2ccf52b
msgid ""
"Dzięki rozszerzeniu języka zapytań o powyższe atrybuty można np. łatwo "
"znaleźć wszystkie rzeczowniki pospolite użyte w funkcji dopełnienia "
"bliższego konkretnego czasownika:"
msgstr ""

#: ../../mtas.rst:529 6d569284b4004967b6152caf521713e0
msgid "[upos=\"NOUN\" & deprel=\"obj\" & head.lemma=\"kupić\"]"
msgstr ""

#: ../../mtas.rst:531 6c40af6f97b5462a810c348fa0fc4663
msgid ""
"Możliwe jest również odwrotne wyszukanie odpowiadające na pytanie, przy "
"jakich czasownikach w roli dopełnienia występuje w korpusie konkretny "
"rzeczownik:"
msgstr ""

#: ../../mtas.rst:537 69309afe0ec945268d199eb9445dc0be
msgid "[deprel=\"obj\" & head.upos=\"VERB\" & lemma=\"osoba\"]"
msgstr ""

#: ../../mtas.rst:539 189bd6309d2b48f384de1ee3b4e27071
msgid ""
"Należy jednak zwrócić uwagę, że w powyższym przykładzie wynikiem "
"zapytania będą wystąpienia rzeczownika :lex:`osoba`, nadrzędne względem "
"nich formy czasownikowe (finitywne i niefinitywne) będą się zaś "
"znajdowały w lewym lub prawym kontekście wyników wyróżnione pismem "
"pogrubionym. Można je jednak zgrupować i posortować względem ich "
"częstości dzięki opcjom Statystyk. Wartością atrybutu ``deprel`` jest "
"jedna z etykiet krawędzi w drzewie zależnościowym odnosząca się do "
"dopełnienia bliższego. Pełny zestaw etykiet relacji zależnościowych "
"znajduje się w `dokumentacji UD "
"<https://universaldependencies.org/u/dep/index.html>`__."
msgstr ""

#: ../../mtas.rst:549 3183135fc8484da69ed4cfa1ee785aed
msgid ""
"Dzięki atrybutowi kodującemu lewo- i prawostronną pozycję nadrzędnika "
"względem segmentu można znaleźć przykłady niekanonicznego szyku zdania, "
"np. podmiotu po orzeczeniu:"
msgstr ""

#: ../../mtas.rst:555 fbf214c736ce4c3194547ef35202792b
msgid "[deprel=\"nsubj\" & head.position=\"left\"]"
msgstr ""

#: ../../mtas.rst:557 66b5bb4930d246d7bae01e1072337ff3
msgid "lub dopełnienia bliższego przed orzeczeniem:"
msgstr ""

#: ../../mtas.rst:561 352bc7c94076457c9345c5286485f9cb
msgid "[deprel=\"obj\" & head.position=\"right\"]"
msgstr ""

#: ../../mtas.rst:563 576d6d5be8bb4c9eba7b606a32b7d311
msgid ""
"Podobnie w wypadku innych konstrukcji — brak określenia pozycji "
"nadrzędnika w zapytaniu:"
msgstr ""

#: ../../mtas.rst:568 96d38e6c095942ed98c05a7af6d0b342
msgid "[upos=\"ADJ\" & deprel=\"amod\" & head.lemma=\"zupa\"]"
msgstr ""

#: ../../mtas.rst:570 e8d41dba74eb4b2f9a819d0dae74d420
msgid ""
"zwróci wszystkie przymiotnikowe określenia rzeczownika :lex:`zupa`. "
"Dodanie parametru pozycji pozwoli ograniczyć wyszukanie do określeń "
"lewostronnych (np. *gorąca zupa*) lub prawostronnych (np. *zupa "
"pomidorowa*)."
msgstr ""

#: ../../mtas.rst:574 4a7bba68ef124de6be73a62110080529
msgid ""
"Częściowa anotacja składniowa pozwala na odnalezienie elementów "
"wypowiedzenia połączonych ze sobą bezpośrednią relacją zależności bez "
"względu na to, czy sąsiadują one ze sobą w porządku linearnym, czy też są"
" przedzielone innymi elementami wypowiedzenia. Atrybut odległości pozwala"
" np. na ograniczenie wyników tylko do takich przypadków, w których "
"elementy nie sąsiadują ze sobą:"
msgstr ""

#: ../../mtas.rst:583 0583f588e74842518efa0e1390cf681c
msgid ""
"[deprel=\"obj\" & head.upos=\"VERB\" & tense=\"past\" & "
"!head.distance=\"1\"]"
msgstr ""

#: ../../mtas.rst:585 a96ca1aa0a1c479ea2b00e7d93401401
msgid ""
"Powyższe przykładowe zapytanie wyszuka dopełnienia bliższe orzeczenia w "
"czasie przeszłym, które są oddzielone od tego orzeczenia co najmniej "
"jednym elementem."
msgstr ""

#: ../../mtas.rst:589 6fca6feece484fa1841d994e8e785ce4
msgid ""
"Innym przykładem użycia znakowania składniowego w korpusie może być "
"zapytanie wyszukujące konstrukcje w stronie biernej:"
msgstr ""

#: ../../mtas.rst:594 94abf03b56814385a80d7200a8eab00c
msgid "[upos=\"AUX\" & deprel=\"aux:pass\" & head.upos=\"ADJ\"]"
msgstr ""

#: ../../mtas.rst:596 ac6c7cde91474de6b8d0eace1cbd8c02
msgid ""
"którego dopasowaniem są słowa posiłkowe konstrukcji biernej połączone z "
"formą imiesłowu biernego (oznaczoną jako przymiotnik) relacją "
"``aux:pass``."
msgstr ""

#: ../../mtas.rst:600 7e0cac9e3c5c481d92fc44142a28d06f
msgid "Warstwa jednostek nazewniczych"
msgstr ""

#: ../../mtas.rst:602 1edeaf1ea17f46a9aef09113d41f974e
msgid ""
"Ostatnią warstwą informacji znakowaną w Korpusomacie jest warstwa "
"jednostek nazewniczych (ang. *named entities*). Są to jednostki tekstowe "
"jedno- lub wielowyrazowe nazywające osoby, miejsca, instytucje czy "
"momenty czasowe. Ponieważ nie istnieje międzynarodowy standard i "
"wielojęzyczny zestaw danych oznakowanych, w których oznakowano w spójny "
"sposób jednostki nazewnicze, zbiór wartości i ich zakres różni się w "
"poszczególnych potokach przetwarzania oraz może być różny dla różnych "
"języków w obrębie tych potoków. Ponadto, nie dla wszystkich języków "
"istnieją odpowiednie modele do oznaczania jednostek nazewniczych."
msgstr ""

#: ../../mtas.rst:611 34416845a703457cb2cbd19b3ae3039e
msgid ""
"Najprostszy i dość często stosowany zestaw etykiet jednostek nazewniczych"
" składa się tylko z czterech elementów: ``PER`` (osoba), ``LOC`` "
"(miejsce), ``ORG`` (organizacja) i ``MISC`` (inne), ale dla niektórych "
"języków istnieją bardziej szczegółowe klasyfikacje, np. języki chiński i "
"angielski w potoku Stanzy mają 18 wartości klasyfikacji jednostek "
"nezewniczych. W poniższych przykładach stosuje się powyższą najprostszą "
"klasyfikację, która dostępna jest np. w potoku Stanzy dla języków "
"hiszpańskiego, francuskiego, rosyjskiego czy ukraińskiego. Pełną listę "
"wartości klasyfikacji dla danego korpusu użytkownik znajdzie w graficznym"
" konstruktorze zapytań."
msgstr ""

#: ../../mtas.rst:620 6b644b9c83944035b6ff5acdc9271219
msgid ""
"Jednostki nazewnicze, podobnie jak opisane wyżej zdania i akapity, "
"przekraczają granicę segmentu, więc można się do nich odnosić w "
"zapytaniach korpusowych tak samo jak do zdań, za pomocą znacznika ``<ne "
"/>``. Obowiązują również te same zasady dotyczące znaku ukośnika wewnątrz"
" znacznika:"
msgstr ""

#: ../../mtas.rst:626 8f449e01b13e491f901a28000816f4d6
msgid "``<ne>`` oznacza początek ciągu opisanego jako jednostka nazewnicza,"
msgstr ""

#: ../../mtas.rst:628 841c5d24cfd1447e86523add5b270ac8
msgid "``</ne>`` oznacza koniec ciągu opisanego jako jednostka nazewnicza."
msgstr ""

#: ../../mtas.rst:630 9babdaf965f442308676535f15bbef01
msgid "Najprostsze możliwe zapytanie tego typu ma postać:"
msgstr ""

#: ../../mtas.rst:634 fd0c84542b6b48618423b93f3946cc0b
msgid "<ne />"
msgstr ""

#: ../../mtas.rst:636 a001d5d584c84e23a90ed0012ca9966a
msgid ""
"i zwróci wszystkie jednostki nazewnicze wszystkich typów odnalezione w "
"korpusie. Wyszukanie można ograniczyć do konkretnego typu nazw np. nazw "
"miejsc:"
msgstr ""

#: ../../mtas.rst:642 d1b8228d35634d6a8f481e764ab34bb6
msgid "<ne=\"LOC\" />"
msgstr ""

#: ../../mtas.rst:644 7abae0ce92ae4865ac7a3c92d1bd14ed
msgid ""
"Podobnie jak w wypadku zdań i akapitów, zapytania o jednostki nazewnicze "
"można łączyć z cechami ortograficznymi i morfosyntaktycznymi segmentów, z"
" których są one zbudowane lub klasyfikacją nazewniczą ich elementów "
"składowych. Oto kilka przykładów takich zapytań:"
msgstr ""

#: ../../mtas.rst:651 71e4c52542284dd5ae82e3cadb2a1b3f
msgid "[upos=\"CCONJ\"] within <ne=\"PER\" />"
msgstr ""

#: ../../mtas.rst:653 25402808ab4b405680f7881652c97c52
msgid ""
"— wszystkie nazwy organizacji zawierające spójnik współrzędny, np. "
"*Krajowa Rada Radiofonii i Telewizji* czy *Instytut Meteorologii i "
"Gospodarki Wodnej*,"
msgstr ""

#: ../../mtas.rst:657 b79dc5a4e68149b6b0be06e81a7500ae
msgid "<ne=\"LOC\" /> [upos=\"CCONJ\"] <ne=\"LOC\" />"
msgstr ""

#: ../../mtas.rst:659 0b56bd3af8214577b126e9d195265f46
msgid ""
"— wystąpienia dwóch nazw geograficznych połączonych spójnikiem "
"współrzędnym, np. *Europa Zachodnia lub Skandynawia*."
msgstr ""

#: ../../mtas.rst:663 6c211c6264af49fc965cfc153b308e2b
msgid "[orth=\"A.*\"][orth=\"M.*\"] fullyalignedwith <ne=\"PER\" />"
msgstr ""

#: ../../mtas.rst:665 59091021afaa42379749a525e7ee0729
msgid ""
"— dwa kolejne segmenty, z których pierwszy zaczyna się od *A*, drugi zaś "
"od *M* i które w całości w tekście występują jako nazwa osoby, np. *Adam "
"Michnik*, *Antoni Macierewicz*."
msgstr ""

#: ../../mtas.rst:667 abc8ea1c4e3e453f9ab1ce10f6d3def3
msgid ""
"Ponadto indeksowany jest również atrybut zawierający informację o "
"długości jednostki nazewniczej mierzonej w segmentach. Zapytanie:"
msgstr ""

#: ../../mtas.rst:671 705f15d9ba08414aa245b32b4bf70fcb
msgid "<ne.len=\"3\" />"
msgstr ""

#: ../../mtas.rst:673 ace8763188194463a5686eb36638b476
msgid ""
"odnajdzie wszystkie takie jednostki składające się z dokładnie trzech "
"segmentów."
msgstr ""

#: ../../mtas.rst:677 1903a060028347468f539e1f3153867d
msgid "Ograniczenie zapytania za pomocą metadanych"
msgstr ""

#: ../../mtas.rst:679 6aa4eef00b5e4dc8b41a5d039a340fca
msgid ""
"Teksty wprowadzane przez użytkownika do Korpusomatu są domyślnie "
"opatrywane czterema polami metadanych o etykietach: autor, tytuł, rok "
"wydania, gatunek. Od użytkownika zależy to, w jaki sposób zostaną one "
"wypełnione, w szczególności mogą pozostać puste. Użytkownik może też "
"zdefiniować własne pola o dowolnych etykietach."
msgstr ""

#: ../../mtas.rst:685 e279b60e1d614e26a9804b3244ce1d23
msgid ""
"Pól metadanych można użyć następnie do ograniczenia zasięgu zapytań w "
"wyszukaniach korpusowych. Służy do tego przycisk metadane, pod którym "
"można zdefiniować takie ograniczenia. Można nałożyć wiele ograniczeń "
"jednocześnie, dodając je za pomocą przycisku dodaj ograniczenie."
msgstr ""

